**1.在controller中的work.ts添加一个mylist()方法来获取用户列表**
```javascript
import { Controller } from 'egg';
import { PopulateOptions } from 'mongoose';
import validateInput from '../decorator/inputValidate';
const workCreateRules = {
  title: 'string',
};
/*
### 查询列表的可变条件
* 页数
* 每页多少条记录返回哪些值 - projection / select
* 关联哪些集合以及返回哪些值 - $lookup/populate
* 排序 - sort = { key: value }
* 查询条件 - query = { key: value }
*/
// 查询条件
export interface IndexCondition {
  pageIndex?: number; // 页数
  pageSize?: number;  // 每页条数
  select?: string | string[]; // 显示列表字段相当于SQL的select  xx , yy, zz from table 
  populate?: PopulateOptions | (PopulateOptions | string)[]; // 关联那集合及返回那些字段 相当于SQL的left join
  customSort?: Record<string, any>; // 自定义指定那个字段进行排序 相当于SQL Order By XXX desc 
  find?: Record<string, any>; // 指定需要查询字段 相当于SQL 的 where xxx = 'xxx01'
}

/*
查询条件 {
  select: 'id author copiedCount coverImag desc title user isHot createAt',
  populate: { path: 'user', select: 'username nickName picture' },
  find: {
    user: '635164bf4fcc1b62187c51f1',
    title: { '$regex': '我的人生', '$options': 'i' }
  },
  pageIndex: 1,
  pageSize: 10
}
*/

export default class WorkController extends Controller {
  @validateInput(workCreateRules, 'workValidateFail')
  async createWork() {
    const { ctx, service } = this;
    const workData = await service.work.createEmptyWork(ctx.request.body);
    ctx.helper.success({ ctx, res: workData });
  }
  async myList() {
    const { ctx } = this;
    const userId = ctx.state.user._id;
    // 从ctx.query 获取查询传入参数
    // 1.页数        --------> pageIndex
    // 2.每页几条     --------> pageSize
    // 3.是否模板     --------> isTemplate
    // 4.作品名称     --------> title
    const { pageIndex, pageSize, isTemplate, title } = ctx.query;
    // 查询条件对象where xxx == 'xxx' 
    const findConditon = {
      user: userId, // 用户只能查询自己的作品，所以默认加user ID 的查询条件
      ...(title && { title: { $regex: title, $options: 'i' } }), // 假如用户有传title条件，就对title进行展正则匹配 
                                                                 // title: { '$regex': '生', '$options': 'i' }
                                                                 // 好比 sql 中 where title like '%xxx%'
      ...(isTemplate && { isTemplate: !!parseInt(isTemplate) }), // 假如用户有传&isTemplate = 1 
                                                                 // 好比 sql 中 where isTemplate = true
    };
    // 组装列表条件 相当于在拼接sql语句（select xxx,yyy from work where xxx='xxx111' order by xxx desc）
    const listCondition: IndexCondition = {
      // 1.列表需要显示的字段 id author copiedCount coverImg desc title user isHot createAt
      select: 'id author copiedCount coverImg desc title user isHot createAt',
      // 2.left join users 集联查询 所join 显示字段username nickName picture
      populate: { path: 'user', select: 'username nickName picture' },
      // 3.查询条件 where title like '%xxxx%'
      find: findConditon,
      // 4.查询展示页数相于分页查询一样
      ...(pageIndex && { pageIndex: parseInt(pageIndex) }),
      // 5.每页展示条数
      ...(pageSize && { pageSize: parseInt(pageSize) }),
    };
    console.log('查询条件', listCondition);
    // 调用service.work.getList(传入列表条进行)查询返回结果
    const res = await this.service.work.getList(listCondition);
    console.log(res);
    ctx.helper.success({ ctx, res });
  }
}

```
**2.在service的work.ts中添加获取列表getList(listCondition)**
```javascript
import { Service } from 'egg';
import { nanoid } from 'nanoid';
import { Types } from 'mongoose';
import { WorkProps } from '../model/work';
import { IndexCondition } from '../controller/work';
// 1.定义默认条件,当用户不输任可查询条件，或只如部分条件
// 系统自动匹配相应默认条件，&pageSize=5, 就取5，如果不输入就是10
// select: '' 表示取 系统定义好列表字段
// populate: [ '' ], 表示集联查询关系字段
// customSort: { createAt: -1 }, 表示能 createAt 创建时间进行倒序
// find: {} 表示 取表传入查询字段
const defaultIndexCondition: Required<IndexCondition> = {
  pageIndex: 1,
  pageSize: 10,
  select: '',
  populate: [ '' ],
  customSort: { createAt: -1 },
  find: {},
};

export default class WorkService extends Service {
  async createEmptyWork(payload) {
    const { ctx } = this;
    // 拿到对应的 user id
    const { username, _id } = ctx.state.user;
    // 拿到一个独一无二的URL id
    const uuid = nanoid(6);
    const newEmptyWork: Partial<WorkProps> = {
      ...payload,
      user: Types.ObjectId(_id),
      author: username,
      uuid,
    };
    return ctx.model.Work.create(newEmptyWork);
  }
  // 从model中获取数据
  // 传入condition条件
  async getList(condition: IndexCondition) {
    // 将默认条件与传入条年进行混合
    const fcondition = { ...defaultIndexCondition, ...condition };
    // 从混合查询条中取出最终的查询参数
    const { pageIndex, pageSize, select, populate, customSort, find } =
      fcondition;
    // 跳过记录（skip） = 页数（pageIndex）* 每页条数
    const skip = (pageIndex - 1) * pageSize;
    // 调用mongoose中find()方法从集合上查找记录
    const res = await this.ctx.model.Work.find(find) // find where 查询条件
      .select(select)                                // select list 字段
      .populate(populate)                            // left join 字段
      .skip(skip)                                    // 从多少条记录开始
      .limit(pageSize)                               // 每页显示条目数
      .sort(customSort)                              // 排序
      .lean();                                       // 从MongooseDocuments转换为JS Object 体积小，性能更好。
    // 取查询结果条目数count()
    const count = await this.ctx.model.Work.find(find).count();
    // 返回查询结果
    return { count, list: res, pageSize, pageIndex };
  }
}

```
